\documentclass{article}
\usepackage{a4wide}
\usepackage[latin1]{inputenc} %             be able to use danish letters
\usepackage[danish]{babel} %                and danish macros
\usepackage{url}                            %, hyperref} hyperref makes clickable refs.
\usepackage{amsmath}
\renewcommand\sfdefault{phv}%               use helvetica for sans serif
\renewcommand\familydefault{\sfdefault}%    use sans serif by default
\setlength{\parskip}{2mm plus1mm minus1mm}% a bit of (rubber) space between paragraphs

\author{Lars Vensild Hørnell \and Søren Mollerup \and Steen
  Manniche\thanks{\{lvh, shm, stm\}\@dbc.dk}}
\date{Version 0.1 \linebreak\today}
\title{OpenSearch javateknologidokument\thanks{Dette dokument kan hentes fra \texttt{svn://svn.dbc.dk/OpenSearch/project\_information}}}

\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage

\section{Behandling af tekstformater}
\subsection{Tegnsæt i java og lucene}
Java bruger som udgangspunkt UTF-8 til at håndtere strenge, men i
visse tilfælde bruger java (såvel som Lucene (=<2.3) i øvrigt)
\textit{modified UTF-8}\footnote{se
  \url{http://java.sun.com/javase/6/docs/api/java/io/DataInput.html#modified-utf-8}
  og
  \url{http://lucene.apache.org/java/docs/fileformats.html#Chars}. Og
  for en længere diskussion af lucene, UTF-8 og \textit{modified
    UTF-8}, se
  \url{http://mail-archives.apache.org/mod_mbox/lucene-java-dev/200509.mbox/browser},
  \url{http://www.archivum.info/java-dev@lucene.apache.org/2005-08/msg00090.html}
  eller
  \url{http://mail-archives.apache.org/mod_mbox/lucene-java-dev/200508.mbox/browser}
  (på side 2)} til at repræsentatere strenge. For javas vedkommende
bruges \textit{modified UTF-8} i forbindelse med objekt
serialisering\footnote{For al type serialisering, der læser binær data
  og forsøger at konvertere denne til e af javas primitive typer.} for
at undgå at der kan indlejres \texttt{null} karakterer i objekt
repræsentationerne. Til al anden strenghåndtering bruges normal
UTF-8. I tilfældet lucene er det besluttet, at fra og med version 2.4,
konformerer lucenes indeks til
UTF-8\footnote{\url{http://issues.apache.org/jira/browse/LUCENE-510}}. Der
er sikret fuld bagud kompatibilitet ved læsning af pre-2.4 indeks i
\textit{modified UTF-8}\footnote{
  vha. \url{http://hudson.zones.apache.org/hudson/job/Lucene-trunk/javadoc//org/apache/lucene/store/IndexInput.html#setModifiedUTF8StringsMode()}}
Så længe der udelukkende bruges lucene\footnote{og her refereres til
  java implementationen. De andre implementationer gør giventvis 'det
  rigtige', men det ligger udenfor dette dokuments opgave at afgøre
  det} 2.3 eller tidligere til både at læse og skrive lucenes
indekser, vil der ikke være nogle problemer i håndteringen af
\textit{modified UTF-8}.

Konklusionen må være at det kun er i forbindelse med læsning og
skrivning af binær data | og herunder hører lucene 2.3 og tidligeres
indeksformat | at der skal tages højde for brugen af non-standard
UTF-8.

\section{Tråde, samtidighed og Junit}
I kataloget Opensearch/examples/src/dbc/threads/sync/test/ i svn
ligger der .java filer der illustrerer brugen af tråde i Java. Det er
filer i det katalog der refereres til i det følgende.

\subsection{Threadpool}

PrintThread.java og ExecutorExp1.java viser en simpel brug af tråde. PrintThread definerer en tråd der i sin run() metode skriver at den sover, hvorefter den gør det og så skriver igen når den er vågnet og derefter lukker ned. ExecutorExp1 opretter et antal PrintThreads og en threadPool med et mindre antal workerthreads. Trådene gives til pool'en og exekverer. Følgende kode opretter pool'en og giver en allerede oprettet tråd til den.

ExecutorService ThreadExecutor = Executors.newFixedThreadPool(3);
		
		ThreadExecutor.execute(thread1);

Det ses at trådene behandles af pool'en i den rækkefølge de gives og at de overskydende tråde behandles som de tidligere givne tråde terminerer.

Efter at trådene er givet til pool'en lukkes denne ned med ``ThreadExecutor.shutdown();`` der lukker og venter til alle tasks givet til pool'en er afsluttet. En ''.shutdownNow()`` ville have termineret tasks der ikke var afsluttet.

Threadpool's skal oprettes med det antal workerthreads, der skal eksekveres. Hvis en tråd bliver sat til at sove med .sleep() startes der ikke en ikke allerede startet tråd op. Med andre ord angiver antallet af workerthreads threadpool'en oprettes med, hvor mange tråde den kan administrere samtidig, sovende som arbejdende.

threadpool's kræver: \newline
import java.util.concurrent.Executors;

Ved at bruge en threadpool til at administrere ens tråde behøver man ikke bekymrer sig om deres liv når de er givet til poolen. Samtidig kan man kontrollere hvor mange task man vil have kørende samtidig, da tråde over threadpoolens antal blot bliver sat i kø.

\subsection{Synkronisering af tråde}
Foretages med låse. Der kan bruges ved ''import java.util.concurrent.locks.Lock;`` I filen ObjectWithLock.java laver jeg en lås i objektet med: public Lock objectLock = new ReentrantLock();
Eksemplet, der består af ObjectWithLock.java, ReadWriteThread.java og ThreadPoolLockExp1.java, viser hvorledes adgangen til objektet OWL styres gennem dets lås. Trådene gives et navn og det samme objekt, OWL. De gives til threadpoolen, der derefter står for deres afvikling. Trådene forsøger at få adgang til objektet OWL gennem først at forsøge at låse dets lås og når dette lykkeds tilgårs resourcerne. Når resourcerne er tilgået låses låsen op. Tråden er sat til at sove mellem den har tilgået objektets resourcer og den låser op. Dette fordi man så kan se, gennem output, at der går noget tid fra der skrives til der åbnes og at låsen umiddelbart efter den er blevet åbnet låses af en anden tråd. Dette illustrerer at trådene sættes i kø af låsen når den er låst af en anden tråd og de låser den så snart den er åben. \newline
Det anbefales at adgangen til et objekt eller en resource styres gennem en lås der er allokeret til det, og ikke også til andre ting, samt at der er een lås pr objekt/resource.

Vi skal naturligvis være opmærksommme på deadlock-problematik hvis en tråd ønsker at låse flere resourcer samtidig.

\section{Unittesting}

En unittest er grundlæggende set afprøvning af en klasse eller en
metodes funktionalitet. Primært tester man for forventede resultater,
der bekræfter funktionaliteten. Sekundært testes forventede
fejlsituationer og om klassen/metoden reagerer korrekt på
fejlsituationer.

Der testes ikke på private funktioner og det skal som udgangspunkt
undgås at en (offentligt tilgængeligt) metode ikke har en unittest.

\subsection{JUnit}

JUnit version 4 bruger javaannotationer til at markere kode som tests. Et eksempel på en annotation er:

\begin{verbatim}
[...]
@Test
public void TestAdditionFunction(){
    Assert.assertEquals( True, AdditionFunction( 2, 2) );
}
[...]
\end{verbatim}

Annotationer i java markeres med et '@' tegn\footnote{Se
  dokumentationen for eksempelvis \texttt{@Test}:
  \url{http://junit.sourceforge.net/javadoc_40/org/junit/Test.html}}
og testfunktionen skal være \texttt{void}. I øvrigt skal unittesten
have adgang til pakken, hvori den klasse der skal tests befinder
sig\footnote{Det er også muligt at udføre unittests på andre måder,
  men de involverer enten at indlejre tests i produktionskode eller at
  bruge \textsf{Reflection}, hvilket i de fleste tilfælde er at
  komplicere testene mere en nødvendigt}; \texttt{dbc.lucene} pakken
testes med unittests i \texttt{dbc.lucene.tests}, eksempelvis.

Der skal kun være en \texttt{assert} pr. testmetode; en
\texttt{assert} giver en boolsk værdi som svar på testen og
unittest-metoden fejler, hvis denne er falsk, så flere
\texttt{asserts} efterfulgt af hinanden kan skygge for fejl.

Hvis der skal sættes variabler eller tilstande op før en test udføres,
kan dette gøres ved at annotere en passende metode med
\texttt{@Before} og omvendt gør det samme sig gældende for operationer
der skal udføres efter en test; med \texttt{@After}. Bemærk at disse
operationer udføres hhv. før og efter \textit{hver} test der udføres i
pågældende testklasse. For at kunne udføre operationer for klassen som
helhed | og dermed blot en gang før alle tests udføres og en gang
efter | bruges \texttt{@BeforeClass} og \texttt{@AfterClass}, hhv.

Hvis en metode testes for hvorvidt den kaster en \texttt{Exception}, bruges \texttt{@Test}-annotationen, efterfulgt af en parantes, der angiver typen af \texttt{Exception}:
\begin{verbatim}
[...]
@Test(expected=ArithmeticException.class) 
public void TestAdditionFunctionFails(){
[...]
\end{verbatim}

\subsection{Code coverage}
For at leve op til vores mål om at alle metoder har tests, påtænker vi
at bruge et 'code coverage' værktøj. Denne type værktøj viser hvor
stor en del af kodebasen, der bliver testet. Code coverage bruges også
til at afsløre to | hyppige | typer af fejlhåndtering af unittests;
\textsf{Happy path}-tests og nemme tests. 

\textsf{Happy path} er tests, der kun tester succesfulde afviklinger
af en given metode. Dvs. en metode gives kun valid inddata og
forventes at være succesfuld i sin afvikling.

Nemme tests er test der er trivielle at verificere. Dette omfatter
typisk \textsf{properties}, der sættes til en værdi og derefter testes
for om den indeholder denne værdi.

For en hurtig oversigt over mulighederne i annotationer, se
\url{http://junit.sourceforge.net/doc/cookbook/cookbook.htm} eller
\url{http://www-128.ibm.com/developerworks/java/library/j-junit4.html}.

\subsection{Easymock}
\textit{Mocking} er at oprette 'falske' objekter for at undgå
afhængiheder at eksterne biblioteker. Easymock er et
letvægts-framework, der sammen med junit giver en bred vifte af
muligheder for at lave unittests med mock-objekter.

Easymock fungerer ved at optage og afspille de forventede resultater
af kald til metoder. Man opretter et mock-objekt, angiver hvilke
metoder de skal indeholder og hvilke værdier det forventes at
returnere (optagning) og giver det til en unittest-metode der så
efterfølgende efterprøver objektet i en test (afspilning.)


\subsection{Unittesting og samtidighed}
Test af trådes samtidighed og herunder især afslutning af trådede
opgaver er notorisk svær at udføre, især overfor byggeservere, der
anser et build for fejlet, hvis det tager for lang tid at gennemføre.

Typisk vil der meningsfuldt foretages to typer af tests på trådede miljøer:

\begin{enumerate}
\item at trådhåndteringsmekanismen fungerer som forventet (dette vil sandsynligvis være i form af en implementation af \texttt{java.util.concurrent.ThreadPoolExecutor}\footnote{\url{http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ThreadPoolExecutor.html}}), og
\item at den funktionalitet der skal tilgås i det trådede miljø er trådsikker\footnote{se wikipedia for en udmærket forklaring: \url{http://en.wikipedia.org/wiki/Threadsafe}}
\end{enumerate}

Trådhåndteringen skal primært tests for at den indeholder de tråde den
skal, at den kan tilgå de objekter den skal, og at den har
funktionalitet til at kunne håndtere tråd-tilstande korrekt.

Testen af, om den funktionalitet der tilgås gennem tråde, rent faktisk
er trådsikker, er mere kompleks - og ikke alle problemområder kan
afdækkes med unittests (men de mest almindelige kan normalt).

\end{document}
